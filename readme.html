<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>openDMR</title>
  <meta name="description" content="openDMR: a cross-platform C++ Digital Mobile Radio (DMR) network server with talkgroup routing, authentication, APRS, SMS, and SQLite logging." />

  <style>
    :root {
      --bg: #0f1115;
      --panel: #121623;
      --panel-2: #151a2b;
      --text: #e6e9ef;
      --muted: #9aa3b2;
      --accent: #7aa2f7;
      --accent-2: #8bd5ff;
      --border: #23283b;
      --code: #0b0e14;
      --ok: #9ece6a;
      --warn: #e0af68;
      --err: #f7768e;
      --shadow: rgba(0,0,0,.25);
      --font: 16px/1.65 Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --mono: 13.5px/1.6 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --topbar-h: 60px;
      --sidebar-w: 280px;
      --ease: cubic-bezier(.22,.61,.36,1);
    }

    [data-theme="light"] {
      --bg: #f7f8fb;
      --panel: #ffffff;
      --panel-2: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --accent: #2563eb;
      --accent-2: #0ea5e9;
      --border: #e5e7eb;
      --code: #f3f4f6;
      --shadow: rgba(0,0,0,.08);
    }

    * { box-sizing: border-box; }
    html, body { margin:0; padding:0; background: var(--bg); color: var(--text); font: var(--font); }

    * { scrollbar-width: none; }
    *::-webkit-scrollbar { width: 0; height: 0; }
    body { -ms-overflow-style: none; }

    .hamburger { display: none; }
    .topbar {
      position: sticky;
      top: 0;
      z-index: 1000;
      height: var(--topbar-h);
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0 14px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
    }
    .brandbar { display:flex; align-items:center; gap:10px; min-width: 140px; }
    .brandbar h1 { font-size: 16px; margin:0; letter-spacing:.2px; }
    .grow { flex: 1; }

    .search-global {
      display:flex; align-items:center; gap:8px; border:1px solid var(--border);
      background: var(--panel-2); padding:8px 10px; border-radius:10px; max-width: 680px; width: 100%;
    }
    .search-global input { flex:1; background: transparent; border:0; outline:0; color:var(--text); font-size:14px; }
    .search-global kbd { background:var(--code); border:1px solid var(--border); padding:2px 6px; border-radius:6px; color: var(--muted); font: var(--mono); }

    .toolbar-top {
      display:flex; gap:8px; margin-left: 8px;
    }
    .btn {
      display:inline-flex; align-items:center; gap:8px; padding:8px 10px;
      background: var(--panel-2); color: var(--text); border:1px solid var(--border);
      border-radius:10px; cursor:pointer; font-size:13px;
      transition: transform .18s var(--ease), filter .18s var(--ease), background .25s var(--ease);
    }
    .btn:hover { filter: brightness(1.05); }

    .app {
      display: grid;
      grid-template-columns: var(--sidebar-w) 1fr;
      min-height: calc(100vh - var(--topbar-h));
    }
    aside {
      position: sticky;
      top: var(--topbar-h);
      height: calc(100vh - var(--topbar-h));
      border-right: 1px solid var(--border);
      background: var(--panel);
      padding: 18px;
      overflow: auto;
      transition: transform .35s var(--ease), opacity .25s var(--ease), visibility .25s var(--ease);
      will-change: transform, opacity;
    }
    main {
      padding: 24px 48px 48px;
      width: 100%;
    }

    nav .group { margin: 16px 0; }
    nav h4 { margin: 8px 0 6px; color: var(--muted); font-size:12px; text-transform: uppercase; letter-spacing:.08em; }
    nav a { display:block; padding:8px 10px; border-radius:8px; color:var(--text); text-decoration:none; font-size:14px; }
    nav a:hover { background: var(--panel-2); transition: background .2s var(--ease); }
    nav a.active { background: linear-gradient(90deg, rgba(122,162,247,.15), transparent); color: var(--accent-2); }

    .toolbar { display:flex; gap:8px; margin-top: 8px; }

    h2 { font-size: 26px; margin: 26px 0 10px; }
    h3 { font-size: 18px; margin: 18px 0 8px; }
    p { margin: 10px 0; }
    .lead { font-size: 18px; color: var(--muted); margin-top:0; }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: 0 6px 18px var(--shadow);
      padding: 18px 18px;
      margin: 14px 0;
      transition: transform .2s var(--ease), box-shadow .2s var(--ease), background .25s var(--ease);
    }
    .card:hover { box-shadow: 0 12px 24px var(--shadow); transform: translateY(-1px); }

    .grid { display:grid; gap:14px; grid-template-columns: repeat(12, 1fr); }
    .col-6 { grid-column: span 6; }
    .col-4 { grid-column: span 4; }
    .col-8 { grid-column: span 8; }
    .col-12 { grid-column: span 12; }

    pre { background: var(--code); border:1px solid var(--border); border-radius:12px; padding:12px; overflow:auto; font: var(--mono); }
    code { background: var(--code); border:1px solid var(--border); border-radius:6px; padding: 2px 6px; font: var(--mono); }
    .copy { float:right; cursor:pointer; font-size:12px; color: var(--accent); }

    table { width: 100%; border-collapse: collapse; font-size: 14px; }
    th, td { border: 1px solid var(--border); padding: 8px 10px; vertical-align: top; }
    th { background: var(--panel-2); text-align: left; }

    .callout { border-left: 4px solid var(--accent); padding: 10px 12px; background: var(--panel); border:1px solid var(--border); border-left-color: var(--accent); border-radius:10px; }
    .ok { border-left-color: var(--ok); }
    .warn { border-left-color: var(--warn); }
    .err { border-left-color: var(--err); }

    footer { margin: 40px 0 20px; color: var(--muted); font-size: 13px; text-align: center; }

    @media (max-width: 600px) {
      main { max-width: 500px; }
    }
    @media (max-width: 1100px) {
      .hamburger {
        width: 40px; height: 40px; border-radius: 10px;
        display: inline-flex; align-items: center; justify-content: center;
        border: 1px solid var(--border); background: var(--panel-2); color: var(--text);
        cursor: pointer; transition: transform .2s var(--ease), filter .2s var(--ease);
      }
      .hamburger:hover { filter: brightness(1.05); }
	}
    @media (max-width: 1100px) {
      .app { grid-template-columns: 1fr; }
      aside {
        position: fixed;
        top: var(--topbar-h);
        left: 0;
        width: min(92vw, var(--sidebar-w));
        height: calc(100vh - var(--topbar-h));
        transform: translateX(-100%);
        opacity: 0;
        visibility: hidden;
        border-right: 1px solid var(--border);
        border-top: 1px solid var(--border);
        border-bottom: 1px solid var(--border);
        border-top-right-radius: 14px;
        border-bottom-right-radius: 14px;
      }
      aside.open {
        transform: translateX(0);
        opacity: 1;
        visibility: visible;
      }
      main { padding: 20px; }
      .col-6, .col-4, .col-8 { grid-column: span 12; }
    }
  </style>
</head>
<body data-theme="dark">
  <div class="topbar">
    <button class="hamburger" id="menuBtn" aria-label="Open navigation" title="Open navigation">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
        <path d="M4 6h16M4 12h16M4 18h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      </svg>
    </button>
    <div class="brandbar">
      <h1>openDMR</h1>
    </div>
    <div class="grow"></div>
    <div class="search-global" role="search">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M21 21l-4.3-4.3m1.8-5.1a7 7 0 11-14 0 7 7 0 0114 0z" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
      <input id="search" placeholder="Search docs ( / )" />
      <kbd>/</kbd>
    </div>
    <div class="toolbar-top">
      <button class="btn" id="themeToggle">Theme</button>
    </div>
  </div>

  <div class="app">
    <aside id="sidebar">
      <nav id="toc">
        <div class="group">
          <h4>Overview</h4>
          <a href="#intro">Introduction</a>
          <a href="#features">Features</a>
          <a href="#quickstart">Quick Start</a>
          <a href="#diagram">Architecture</a>
        </div>
        <div class="group">
          <h4>Build & Deploy</h4>
          <a href="#build">Build & Install</a>
          <a href="#config">Configuration Reference</a>
          <a href="#defaults">Defaults & Constants</a>
        </div>
        <div class="group">
          <h4>Internals</h4>
          <a href="#protocol">DMR Protocol</a>
          <a href="#packets">Packet Types</a>
          <a href="#threading">Threading & Timing</a>
          <a href="#datastructs">Core Data Structures</a>
          <a href="#stateflow">State & Flow</a>
          <a href="#api">API Reference</a>
        </div>
        <div class="group">
          <h4>Usage</h4>
          <a href="#runtime">Runtime & CLI</a>
          <a href="#logging">Logging</a>
          <a href="#faq">FAQ</a>
        </div>
        <div class="group">
          <h4>Project</h4>
          <a href="#contrib">Contributing</a>
          <a href="#license">License</a>
        </div>

        <div class="toolbar">
          <button class="btn" id="expandAll">Expand All</button>
        </div>
      </nav>
    </aside>

    <main id="content">
      <section id="intro" class="card">
        <h2>Introduction</h2>
        <p class="lead">
          <strong>openDMR</strong> is a cross-platform C++ Digital Mobile Radio (DMR) master/server that links repeaters,
          routes talkgroups, authenticates nodes, and optionally integrates APRS, DMR-SMS, and SQLite logging.
          It is built around a compact core with a focus on performance and clarity.
        </p>
        <div class="callout ok"><strong>Highlights:</strong> UDP networking, SHA-256 authentication, Parrot echo TG, APRS/SMS modules, SQLite logging, Linux/Windows support.</div>
      </section>

      <section id="features" class="card">
        <h2>Features</h2>
        <div class="grid">
          <div class="col-6">
            <ul>
              <li>DMR UDP protocol handling (<code>DMRD</code>, <code>RPTL</code>, <code>RPTK</code>, <code>RPTC</code>, heartbeats)</li>
              <li>Talkgroup management with owner-slot arbitration & scanner TG</li>
              <li>Parrot TG (9990) recording and playback</li>
              <li>SHA-256 challenge/response auth with per-node policy</li>
              <li>Optional APRS: heard reports to APRS-IS</li>
            </ul>
          </div>
          <div class="col-6">
            <ul>
              <li>Optional DMR-SMS: frame buffering and UDP emission</li>
              <li>Optional SQLite3: activity & transmission logs</li>
              <li>Colorized console logging</li>
              <li>INI configuration parser included</li>
              <li>Cross-platform (Linux / Windows)</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="quickstart" class="card">
        <h2>Quick Start</h2>
        <h3>Linux</h3>
        <pre><span class="copy" data-copy="#qs1">Copy</span><code id="qs1">g++ -O2 -std=c++17 server.cpp -o dmr -lpthread
./dmr</code></pre>
        <h3>Linux with SQLite & APRS</h3>
        <pre><span class="copy" data-copy="#qs2">Copy</span><code id="qs2">g++ -O2 -std=c++17 server.cpp -o dmr -DUSE_SQLITE3 -DHAVE_APRS -lsqlite3 -lpthread
./dmr</code></pre>
        <h3>Windows (MinGW)</h3>
        <pre><span class="copy" data-copy="#qs3">Copy</span><code id="qs3">g++ -O2 -std=c++17 server.cpp -lws2_32 -o dmr.exe
dmr.exe</code></pre>
      </section>

      <section id="diagram" class="card">
        <h2>Architecture</h2>
        <p>The core is an event-driven UDP loop with light worker threads for timing and parrot playback; APRS and SMS are optional sub-systems.</p>
        <div id="svgwrap" style="background:var(--panel-2); border:1px solid var(--border); border-radius:12px; padding:10px;">
          <svg id="diagramSVG" width="100%" height="280" viewBox="0 0 900 280"></svg>
        </div>
      </section>

      <section id="build" class="card">
        <h2>Build & Install</h2>
        <h3>Dependencies</h3>
        <ul>
          <li>C++17 compiler</li>
          <li>POSIX sockets (Linux) or WinSock (Windows)</li>
          <li>(Optional) SQLite3</li>
          <li>(Optional) OpenSSL (if you wire HMAC helpers)</li>
        </ul>

        <h3>Compile</h3>
        <pre><code>g++ -O2 -std=c++17 server.cpp -o dmr -lpthread</code></pre>
        <p>With optional modules:</p>
        <pre><code>g++ -O2 -std=c++17 server.cpp -o dmr -DUSE_SQLITE3 -DHAVE_APRS -DHAVE_SMS -lsqlite3 -lpthread</code></pre>
      </section>

      <section id="config" class="card">
        <h2>Configuration Reference</h2>
        <p>openDMR ships a minimal INI parser (<code>config_file</code>) supporting <em>[sections]</em> and <em>key=value</em> pairs. Boolean values accept: <code>on/off</code>, <code>true/false</code>, <code>yes/no</code>.</p>
        <div class="grid">
          <div class="col-6">
            <h3>[Server]</h3>
            <table>
              <tr><th>Key</th><th>Description</th><th>Default</th></tr>
              <tr><td>Port</td><td>UDP server port</td><td><code>62031</code></td></tr>
              <tr><td>Password</td><td>Global network password</td><td>—</td></tr>
              <tr><td>Debug</td><td>Verbose logging</td><td><code>0</code></td></tr>
            </table>
            <h3>[Auth]</h3>
            <table>
              <tr><th>Key</th><th>Description</th><th>Default</th></tr>
              <tr><td>Enabled</td><td>Enable per-node authorization</td><td><code>0</code></td></tr>
              <tr><td>File</td><td>Authorization file path</td><td>—</td></tr>
              <tr><td>ReloadSecs</td><td>Hot-reload interval</td><td>—</td></tr>
              <tr><td>UnknownDefault</td><td>Policy for unknown nodes (1=allow,0=deny)</td><td><code>0</code></td></tr>
            </table>
          </div>
          <div class="col-6">
            <h3>[APRS]</h3>
            <table>
              <tr><th>Key</th><th>Description</th><th>Default</th></tr>
              <tr><td>Enabled</td><td>Enable APRS module</td><td><code>0</code></td></tr>
              <tr><td>ServerHost</td><td>APRS-IS host</td><td>—</td></tr>
              <tr><td>ServerPort</td><td>APRS-IS port</td><td><code>14580</code></td></tr>
              <tr><td>Callsign</td><td>APRS callsign</td><td>—</td></tr>
              <tr><td>Passcode</td><td>APRS passcode</td><td>—</td></tr>
              <tr><td>Filter</td><td>APRS filter string</td><td><code>m/0</code></td></tr>
              <tr><td>KeepAliveSecs</td><td>APRS keepalive cadence</td><td>—</td></tr>
              <tr><td>ReconnectSecs</td><td>Reconnect cadence</td><td>—</td></tr>
            </table>

            <h3>[SMS]</h3>
            <table>
              <tr><th>Key</th><th>Description</th><th>Default</th></tr>
              <tr><td>Enabled</td><td>Enable DMR-SMS module</td><td><code>0</code></td></tr>
              <tr><td>UdpHost</td><td>SMS UDP target host</td><td>—</td></tr>
              <tr><td>UdpPort</td><td>SMS UDP target port</td><td>—</td></tr>
              <tr><td>AllowPrivate</td><td>Permit private SMS</td><td><code>1</code></td></tr>
              <tr><td>PermitTGs</td><td>CSV of permitted TGs</td><td>—</td></tr>
              <tr><td>MaxFrames</td><td>Frame limit per message</td><td>—</td></tr>
              <tr><td>MaxSeconds</td><td>Time window per message</td><td>—</td></tr>
            </table>
          </div>
        </div>
      </section>

      <section id="defaults" class="card">
        <h2>Defaults & Constants</h2>
        <table>
          <tr><th>Symbol</th><th>Value</th><th>Description</th></tr>
          <tr><td><code>DEFAULT_PORT</code></td><td><code>62031</code></td><td>Main UDP port</td></tr>
          <tr><td><code>LOW_DMRID</code></td><td><code>1000000</code></td><td>Lower user ID bound</td></tr>
          <tr><td><code>HIGH_DMRID</code></td><td><code>8000000</code></td><td>Upper user ID bound</td></tr>
          <tr><td><code>UNSUBSCRIBE_ALL_TG</code></td><td><code>4000</code></td><td>Unsubscribe control TG</td></tr>
          <tr><td><code>g_scanner_tg</code></td><td><code>777</code></td><td>Scanner group</td></tr>
          <tr><td><code>g_parrot_tg</code></td><td><code>9990</code></td><td>Parrot echo group</td></tr>
          <tr><td><code>g_aprs_tg</code></td><td><code>900999</code></td><td>APRS heard trigger</td></tr>
          <tr><td><code>DMRD_TOTAL_NO_HMAC</code></td><td><code>55</code></td><td>Size of DMRD frame sans HMAC</td></tr>
          <tr><td><code>DMRD_TOTAL_WITH_HMAC</code></td><td><code>75</code></td><td>Size of DMRD frame with HMAC</td></tr>
        </table>
      </section>

      <section id="protocol" class="card">
        <h2>DMR Protocol Format</h2>
        <p>This section documents the subset handled by openDMR based on the server implementation.</p>

        <h3>DMRD (55 bytes, no HMAC)</h3>
        <table>
          <tr><th>Offset</th><th>Size</th><th>Field</th><th>Notes</th></tr>
          <tr><td>0</td><td>4</td><td>Magic</td><td>ASCII <code>"DMRD"</code></td></tr>
          <tr><td>4</td><td>1</td><td>Flags (internal)</td><td>See <em>Flags</em> below</td></tr>
          <tr><td>5</td><td>3</td><td>Radio ID</td><td><code>get3(pk+5)</code></td></tr>
          <tr><td>8</td><td>3</td><td>Destination</td><td>Group or private ID (TG or radio), <code>get3(pk+8)</code></td></tr>
          <tr><td>11</td><td>4</td><td>Node ID</td><td><code>get4(pk+11)</code></td></tr>
          <tr><td>15</td><td>1</td><td>Flags</td><td>Start/End, Private, Slot bit</td></tr>
          <tr><td>16</td><td>4</td><td>Stream ID</td><td><code>get4(pk+16)</code></td></tr>
          <tr><td>20</td><td>35</td><td>Payload</td><td>DMR voice/data block (51 bytes total incl. header subset)</td></tr>
          <tr><td>…</td><td>—</td><td>Total</td><td><code>55</code> bytes</td></tr>
        </table>

        <h4>Flags</h4>
        <ul>
          <li><code>bStartStream</code>: <code>(flags &amp; 0x23) == 0x21</code></li>
          <li><code>bEndStream</code>: <code>(flags &amp; 0x23) == 0x22</code></li>
          <li><code>bPrivateCall</code>: <code>(flags &amp; 0x40) != 0</code></li>
          <li><strong>Slot select:</strong> bit <code>0x80</code> is set for TS2 in forwarding, cleared for TS1</li>
        </ul>

        <h3>Login / Control Frames</h3>
        <table>
          <tr><th>Type</th><th>Magic</th><th>Size</th><th>Key Fields</th><th>Description</th></tr>
          <tr><td>Login</td><td><code>"RPTL"</code></td><td>8</td><td>NodeID</td><td>Node requests login; server replies <code>RPTACK</code> + salt</td></tr>
          <tr><td>Auth</td><td><code>"RPTK"</code></td><td>40</td><td>NodeID, SHA256(salt||pass)</td><td>Client sends auth response; server replies <code>RPTACK</code> or <code>MSTNAK</code></td></tr>
          <tr><td>Config</td><td><code>"RPTC"</code>/<code>"RPTO"</code></td><td>≥12</td><td>NodeID, INI-like payload</td><td>Applies static TGs: <code>TS1=</code>, <code>TS2=</code> (CSV)</td></tr>
          <tr><td>Ping</td><td><code>"RPTPING"</code></td><td>11</td><td>NodeID</td><td>Pong with <code>"MSTPONG"</code> + NodeID</td></tr>
          <tr><td>Ping2</td><td><code>"FMRPING"</code></td><td>11</td><td>—</td><td>Compatibility pong <code>"FMRPONG"</code></td></tr>
          <tr><td>Logout</td><td><code>"RPTCL"</code></td><td>9</td><td>NodeID</td><td>Node disconnect</td></tr>
          <tr><td>Status</td><td><code>"/STAT"</code></td><td>5</td><td>—</td><td>Local status dump to <code>127.0.0.1:Port</code></td></tr>
        </table>

        <h3>Special Talkgroups</h3>
        <ul>
          <li><strong>Unsubscribe all:</strong> <code>4000</code> (on start, server clears subscriptions)</li>
          <li><strong>Parrot:</strong> <code>9990</code> (records on start, replays on end)</li>
          <li><strong>APRS trigger:</strong> <code>900999</code> (heard report)</li>
          <li><strong>Scanner:</strong> <code>777</code> (temporary owner until traffic ends)</li>
        </ul>
      </section>

      <section id="packets" class="card">
        <h2>Packet Types & Flow</h2>
        <ol>
          <li><strong>Login:</strong> <code>RPTL</code> → <code>RPTACK</code>(salt)</li>
          <li><strong>Auth:</strong> <code>RPTK</code>(SHA256(salt||pass)) → <code>RPTACK</code> or <code>MSTNAK</code></li>
          <li><strong>Config:</strong> <code>RPTC/RPTO</code> sets static TGs for TS1/TS2</li>
          <li><strong>Traffic:</strong> <code>DMRD</code> frames → routed to all subscribers of the talkgroup (owner slot arbitration)</li>
          <li><strong>Keepalive:</strong> <code>RPTPING</code> ↔ <code>MSTPONG</code></li>
          <li><strong>Logout:</strong> <code>RPTCL</code></li>
        </ol>
      </section>

      <section id="threading" class="card">
        <h2>Threading & Timing</h2>
        <ul>
          <li><strong>Time thread</strong> (<code>time_thread_proc</code>): increments <code>g_tick</code> every 50ms and <code>g_sec</code> each second.</li>
          <li><strong>Parrot playback</strong> (<code>parrot_playback_thread_proc</code>): replays buffered frames (~20ms pacing).</li>
          <li><strong>Main loop</strong>: UDP <code>select()</code> on server socket, dispatches to <code>handle_rx()</code>.</li>
          <li><strong>APRS/SMS housekeeping</strong> (optional): keepalives, reconnects, and buffer emission.</li>
        </ul>
      </section>

      <section id="datastructs" class="card">
        <h2>Core Data Structures</h2>
        <ul>
          <li><code>struct node</code>: nodeid, dmrid, salt, sockaddr, hitsec, slots[2], auth flag, timer, static TGs</li>
          <li><code>struct slot</code>: back-ref node, slotid, current tg, parrot buffer/seq/timestamps, optional SMS buffer</li>
          <li><code>struct talkgroup</code>: tg number, ownerslot, tick, linked-list subscribers</li>
          <li><code>class memfile</code>: in-memory expanding buffer (Read/Write/Seek)</li>
          <li><code>class config_file</code>: INI loader (<code>getstring</code>, <code>getint</code>)</li>
        </ul>
      </section>

      <section id="stateflow" class="card">
        <h2>State & Flow</h2>
        <p>Owner-slot arbitration prevents collisions: the first slot to key up on a TG takes ownership; ownership drops on end/timeout (~1.5s).</p>
        <ul>
          <li>Joining a TG calls <code>subscribe_to_group()</code> (singly linked list insert).</li>
          <li>Leaving TG or on control TG <code>4000</code> calls <code>unsubscribe_from_group()</code>.</li>
          <li>Scanner owner (<code>g_scanner</code>) follows the last active slot until end/timeout.</li>
        </ul>
      </section>

      <section id="api" class="card">
        <h2>API Reference (from <code>server.h</code>)</h2>
        <h3>Core</h3>
        <table>
          <tr><th>Function</th><th>Signature</th><th>Description</th></tr>
          <tr><td>init_process</td><td><code>void init_process()</code></td><td>Initialize process (signals/WSA/umask).</td></tr>
          <tr><td>open_udp</td><td><code>int open_udp(int port)</code></td><td>Create & bind UDP socket.</td></tr>
          <tr><td>IsOptionPresent</td><td><code>bool IsOptionPresent(int argc, char **argv, PCSTR arg)</code></td><td>CLI helper.</td></tr>
          <tr><td>make_sha256_hash</td><td><code>byte* make_sha256_hash(const void* src, int n, byte* dest, const void* salt, int saltN)</code></td><td>SHA-256 (internal implementation included).</td></tr>
          <tr><td>select_rx</td><td><code>bool select_rx(int sock, int wait_secs)</code></td><td>select() wrapper for RX readiness.</td></tr>
          <tr><td>skipspaces</td><td><code>PCSTR skipspaces(PCSTR p, bool bSkipTabs=true, bool bSkipCtrl=false)</code></td><td>Parsing helper.</td></tr>
          <tr><td>trim</td><td><code>void trim(std::string&amp; s)</code></td><td>Right-trim string.</td></tr>
        </table>

        <h3>Outbound Peer (OBP)</h3>
        <table>
          <tr><th>Function</th><th>Signature</th><th>Description</th></tr>
          <tr><td>obp_fetch_check</td><td><code>bool obp_fetch_check(int timeout_ms)</code></td><td>Check socket/event.</td></tr>
          <tr><td>obp_init</td><td><code>void obp_init()</code></td><td>Initialize peer state.</td></tr>
          <tr><td>resolve_hostname_ipv4</td><td><code>bool resolve_hostname_ipv4(PCSTR host, in_addr* out)</code></td><td>DNS IPv4 resolve.</td></tr>
          <tr><td>obp_resolve_now</td><td><code>bool obp_resolve_now()</code></td><td>Force resolve.</td></tr>
          <tr><td>obp_set_target</td><td><code>void obp_set_target(PCSTR host, int port)</code></td><td>Set forward target.</td></tr>
          <tr><td>obp_housekeeping / _all</td><td><code>void obp_housekeeping(); void obp_housekeeping_all();</code></td><td>Periodic upkeep.</td></tr>
          <tr><td>obp_handle_rx / _all</td><td><code>void obp_handle_rx(); void obp_handle_rx_all();</code></td><td>Receive path.</td></tr>
          <tr><td>obp_forward_dmrd</td><td><code>void obp_forward_dmrd(const byte* pk, int sz, int origin_tag)</code></td><td>Forward DMRD frames.</td></tr>
        </table>

        <h3>Auth</h3>
        <table>
          <tr><th>Function</th><th>Signature</th><th>Description</th></tr>
          <tr><td>auth_load_initial</td><td><code>void auth_load_initial()</code></td><td>Initial load.</td></tr>
          <tr><td>auth_housekeeping</td><td><code>void auth_housekeeping()</code></td><td>Reload on interval.</td></tr>
          <tr><td>auth_lookup_pass</td><td><code>const char* auth_lookup_pass(dword dmrid)</code></td><td>Lookup pass for node.</td></tr>
        </table>

        <h3>APRS (optional)</h3>
        <table>
          <tr><th>Function</th><th>Signature</th><th>Description</th></tr>
          <tr><td>aprs_init_from_config</td><td><code>bool aprs_init_from_config()</code></td><td>Initialize APRS client.</td></tr>
          <tr><td>aprs_housekeeping</td><td><code>void aprs_housekeeping()</code></td><td>Keepalive & reconnect.</td></tr>
          <tr><td>aprs_send_heard</td><td><code>void aprs_send_heard(dword dmrid, dword tg, dword nodeid)</code></td><td>Emit heard line.</td></tr>
          <tr><td>aprs_load_idmap</td><td><code>bool aprs_load_idmap(const char* path)</code></td><td>Load DMRID→callsign map.</td></tr>
          <tr><td>aprs_lookup_callsign</td><td><code>const char* aprs_lookup_callsign(dword dmrid)</code></td><td>Lookup callsign.</td></tr>
        </table>

        <h3>SMS (optional)</h3>
        <table>
          <tr><th>Function</th><th>Signature</th><th>Description</th></tr>
          <tr><td>sms_tg_permitted</td><td><code>bool sms_tg_permitted(dword tg)</code></td><td>TG filter policy.</td></tr>
          <tr><td>sms_reset</td><td><code>void sms_reset(struct sms_buf&amp;)</code></td><td>Clear buffer.</td></tr>
          <tr><td>sms_append</td><td><code>void sms_append(struct sms_buf&amp;, const byte* block51)</code></td><td>Append block.</td></tr>
          <tr><td>sms_emit_udp</td><td><code>void sms_emit_udp(dword radioid, dword dest, bool is_private, struct sms_buf&amp;)</code></td><td>Emit to UDP.</td></tr>
          <tr><td>sms_housekeeping</td><td><code>void sms_housekeeping()</code></td><td>Timers & limits.</td></tr>
          <tr><td>sms_init_from_config</td><td><code>bool sms_init_from_config(class config_file&amp; c)</code></td><td>Initialize SMS.</td></tr>
        </table>
      </section>

      <section id="runtime" class="card">
        <h2>Runtime & CLI</h2>
        <pre><code># start
./dmr

# local status (UDP)
echo "/STAT" | nc -u 127.0.0.1 62031</code></pre>
      </section>

      <section id="logging" class="card">
        <h2>Logging</h2>
        <p>Console logs use colored levels via <code>logmsg(level, timed, ...)</code> (Linux ANSI / Windows Console API). SQLite logging (if enabled) writes to a <code>LOG</code> table with columns such as <em>DATE, RADIO, TG, SLOT, NODE, ACTIVE, CONNECT, TIME</em>.</p>
      </section>

      <section id="faq" class="card">
        <h2>FAQ</h2>
        <details open>
          <summary>What happens when a node sends to an unknown TG?</summary>
          <p>The server creates the talkgroup on demand and subscribes the slot if requested via config; otherwise keyup on a non-existent group logs a notice and the slot is unsubscribed.</p>
        </details>
        <details>
          <summary>How are private calls routed?</summary>
          <p>If the destination is a radio ID within range and present in the node index, the frame is forwarded to that radio's last seen slot, with the slot bit adjusted.</p>
        </details>
        <details>
          <summary>How does Parrot work?</summary>
          <p>On start: create <code>memfile</code> buffer; on end: spawn playback thread to echo frames back at ~20ms cadence.</p>
        </details>
      </section>

      <section id="contrib" class="card">
        <h2>Contributing</h2>
        <ol>
          <li>Fork the repository and create a feature branch: <code>feat/&lt;topic&gt;</code> or <code>fix/&lt;scope&gt;</code>.</li>
          <li>Follow code style used in this project (C++17, RAII where possible, minimal global state in new code).</li>
          <li>Prefer small, focused PRs; include a short design note if behavior changes network semantics.</li>
          <li>Commit message convention (recommended): <code>type(scope): brief summary</code>.</li>
          <li>Run on both Linux and Windows (or CI matrix) where feasible.</li>
        </ol>
        <p class="callout warn"><strong>Note:</strong> Please avoid introducing new external runtime dependencies—keep the binary lean and portable.</p>
      </section>

      <section id="license" class="card">
        <h2>License</h2>
        <p>Provided as-is for educational and amateur radio experimentation. Ensure compliance with regional regulations.</p>
      </section>

      <footer>
        openDMR © 2025
      </footer>
    </main>
  </div>

  <script>
    const themeBtn = document.getElementById('themeToggle');
    const current = localStorage.getItem('opendmr-theme') || document.body.dataset.theme || 'dark';
    document.body.dataset.theme = current;
    themeBtn.addEventListener('click', () => {
      const t = document.body.dataset.theme === 'light' ? 'dark' : 'light';
      document.body.dataset.theme = t;
      localStorage.setItem('opendmr-theme', t);
    });

    const menuBtn = document.getElementById('menuBtn');
    const sidebar = document.getElementById('sidebar');
    function openSidebar() {
      sidebar.classList.add('open');
      menuBtn.setAttribute('aria-label', 'Close navigation');
    }
    function closeSidebar() {
      sidebar.classList.remove('open');
      menuBtn.setAttribute('aria-label', 'Open navigation');
    }
    function toggleSidebar() {
      if (sidebar.classList.contains('open')) closeSidebar(); else openSidebar();
    }
    menuBtn.addEventListener('click', toggleSidebar);
    document.querySelectorAll('#sidebar a').forEach(a => a.addEventListener('click', () => {
      closeSidebar();
    }));

    const search = document.getElementById('search');
    window.addEventListener('keydown', (e) => {
      if (e.key === '/' && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
        e.preventDefault(); search.focus();
      }
    });
    search.addEventListener('input', () => {
      const q = search.value.trim().toLowerCase();
      document.querySelectorAll('main .card').forEach(sec => {
        const hit = sec.innerText.toLowerCase().includes(q);
        sec.style.display = hit ? '' : 'none';
      });
    });

    document.querySelectorAll('.copy').forEach(btn => {
      btn.addEventListener('click', () => {
        const sel = btn.getAttribute('data-copy');
        const el = document.querySelector(sel);
        if (!el) return;
        navigator.clipboard.writeText(el.innerText);
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = 'Copy', 1500);
      });
    });

    const expandAll = document.getElementById('expandAll');
    expandAll.addEventListener('click', () => {
      document.querySelectorAll('details').forEach(d => d.open = true);
    });

    const links = document.querySelectorAll('aside nav a');
    const onScroll = () => {
      let fromTop = window.scrollY + 120;
      links.forEach(link => {
        const sec = document.querySelector(link.getAttribute('href'));
        if (!sec) return;
        if (sec.offsetTop <= fromTop && sec.offsetTop + sec.offsetHeight > fromTop) {
          links.forEach(l => l.classList.remove('active'));
          link.classList.add('active');
        }
      });
    };
    document.addEventListener('scroll', onScroll); onScroll();

    const svg = document.getElementById('diagramSVG');
    const NS = 'http://www.w3.org/2000/svg';
    function rect(x,y,w,h,r=10,label='') {
      const g = document.createElementNS(NS, 'g');
      const s = document.createElementNS(NS, 'rect');
      s.setAttribute('x', x); s.setAttribute('y', y);
      s.setAttribute('width', w); s.setAttribute('height', h); s.setAttribute('rx', r);
      s.setAttribute('fill', 'none'); s.setAttribute('stroke', 'currentColor'); s.setAttribute('opacity', '.8');
      g.appendChild(s);
      if (label) {
        const t = document.createElementNS(NS, 'text');
        t.setAttribute('x', x + w/2); t.setAttribute('y', y + h/2);
        t.setAttribute('fill', 'currentColor'); t.setAttribute('font-size', '14'); t.setAttribute('text-anchor', 'middle'); t.setAttribute('dominant-baseline', 'middle');
        t.textContent = label;
        g.appendChild(t);
      }
      svg.appendChild(g);
      return g;
    }
    function arrow(x1,y1,x2,y2,label='') {
      const l = document.createElementNS(NS, 'line');
      l.setAttribute('x1', x1); l.setAttribute('y1', y1);
      l.setAttribute('x2', x2); l.setAttribute('y2', y2);
      l.setAttribute('stroke', 'currentColor'); l.setAttribute('marker-end', 'url(#arrow)');
      svg.appendChild(l);
      if (label) {
        const t = document.createElementNS(NS, 'text');
        t.setAttribute('x', (x1+x2)/2); t.setAttribute('y', (y1+y2)/2 - 6);
        t.setAttribute('fill', 'currentColor'); t.setAttribute('font-size', '12'); t.setAttribute('text-anchor', 'middle');
        t.textContent = label;
        svg.appendChild(t);
      }
    }
    const defs = document.createElementNS(NS, 'defs');
    defs.innerHTML = '<marker id="arrow" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L6,3 z" fill="currentColor"/></marker>';
    svg.appendChild(defs);

    rect(40, 50, 200, 70, 10, 'DMR Repeaters');
    rect(350, 40, 200, 90, 10, 'openDMR Core\nUDP Loop');
    rect(350, 150, 200, 60, 10, 'Talkgroups & Index');
    rect(660, 40, 200, 60, 10, 'APRS (opt)');
    rect(660, 120, 200, 60, 10, 'DMR-SMS (opt)');
    rect(660, 200, 200, 60, 10, 'SQLite (opt)');

    arrow(240, 85, 350, 85, 'DMRD / RPT*');
    arrow(450, 130, 450, 150, '');
    arrow(550, 70, 660, 70, 'heard');
    arrow(550, 150, 660, 150, 'SMS');
    arrow(550, 210, 660, 210, 'logs');
  </script>
</body>
</html>
